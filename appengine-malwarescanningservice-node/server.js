/*
* Copyright 2019 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const clamd = require('clamdjs');
const NodeClam = require('clamscan');

const express = require('express');
const fs = require('fs');
const bodyParser = require('body-parser');
const { Storage } = require('@google-cloud/storage');

const app = express();
const PORT = process.env.PORT || 8080;
const CLOUD_STORAGE_BUCKET = process.env.UNSCANNED_BUCKET;
const CLEAN_BUCKET = process.env.CLEAN_BUCKET;
const QUARANTINED_BUCKET = process.env.QUARANTINED_BUCKET;

const scanner = clamd.createScanner('172.0.0.1', 3310);

/*
TODO
* Configire clamd options as env vars
* Compare speeds between clamdjs and clamscan
*/

app.use(bodyParser.json());

// Creates a client
const storage = new Storage();

// Get the bucket which is declared as an environment variable
const srcbucket = storage.bucket(CLOUD_STORAGE_BUCKET);

const run = () => app.listen(PORT, () => {
  console.log(`Server started on port ${PORT}`);
})

/**
 * Route that is invoked by a Cloud Function when a malware scan is requested
 * for a document uploaded to GCS.
 *
 * @param {object} req The request payload
 * @param {object} res The HTTP response object
 */
app.post('/scan', async (req, res) => {
  console.log('Request body', req.body);

  try {
    const fileName = req.body.filename;
    const filePath = `/unscanned_files/${fileName}`;

    const options = {
      destination: filePath
    };

    //Downloads the file
    await storage
      .bucket(CLOUD_STORAGE_BUCKET)
      .file(fileName)
      .download(options);


    console.log(`File saved in : ${filePath}`);

    await scanWithClamScan(filePath)

    const result = await scanner.scanFile(filePath);

    console.log(`Scan results : `, result);

    if (result.indexOf('OK') > -1) {
      // Move document to the bucket that holds clean documents
      await moveProcessedFile(fileName, true);

      // Log scan outcome for document
      console.log(`Scan status for ${fileName}: CLEAN`)

      // Delete file from the local directory on the container
      deleteLocalCopy(filePath, fileName);

      // Respond to API client
      res.json({ status: 'clean' });
    } else {

      // Log scan outcome for document
      console.log(`Scan status for ${fileName}: INFECTED`)

      // Move document to the bucket that holds infected documents
      await moveProcessedFile(fileName, false);

      // Delete file from the local directory on the container
      deleteLocalCopy(filePath, fileName);

      // Respond to API client
      res.json({
        message: result,
        status: 'infected'
      });
    }

  } catch (err) {
    console.error(`Error processing the file : `, err)
    res.status(500).json({
      message: err.toString(),
      status: 'error'
    });
  }
})

async function scanWithClamScan(filePath) {
  try {
    const clamscan = await new NodeClam().init({
      remove_infected: false,
      quarantine_infected: false,
      clamdscan: {
        socket: null,
        host: '127.0.0.1',
        port: 3310
      }
    });

    console.log(`[SlamScan] ClamAV Version: ${await clamscan.get_version()}`);

    const { is_infected, file, viruses } = await clamscan.is_infected(filePath);

    if (is_infected) {
      console.log(`[SlamScan] ${file} is infected with ${viruses}!`)
    } else {
      console.log(`[SlamScan] ${file} is CLEAN ðŸ§¼âœ¨!`)
    };
  } catch (err) {
    console.error(`Error scanning ${filePath}  : `, err);
  }
}

const deleteLocalCopy = (loc, filename) => {
  try {
    fs.unlink(loc, (err) => {
      if (err) {
        console.error(`Error deleting file ${filename}`);
      } else {
        console.log(`File ${filename} was deleted successfully`);
      }
    })
  } catch (error) {
    console.error(`Error deleting local ${filename}  : `, error);
  }
}

const moveProcessedFile = async (filename, isClean) => {
  try {
    const srcfile = srcbucket.file(filename);
    const destinationBucketName = isClean ? `gs://${CLEAN_BUCKET}` : `gs://${QUARANTINED_BUCKET}`;
    const destinationBucket = storage.bucket(destinationBucketName);
    await srcfile.move(destinationBucket);

    console.log(`File ${filename} was successfully moved to ${destinationBucketName}`);
  } catch (error) {
    console.error(`Error moving ${filename} to destinationBucketName : `, error);
  }
}

run();